# -*- coding: utf-8 -*-
"""HoughTrans.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EZHNDugr2YibY3G-IG3P9wrGO1MHCsrE
"""

import cv2 as cv
import pandas as pd
import numpy as np
from google.colab.patches import cv2_imshow 
import math
import matplotlib.pyplot as plt
from skimage.transform import hough_line, hough_line_peaks

img= cv.imread("/content/clock_2.jpg")
gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY)
cv2_imshow(gray)

gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)
edges = cv.Canny(gray,50,150,apertureSize = 3)
cv2_imshow(edges)

print(edges)
print(edges.shape)
print(len(edges[0]))
def HoughTrans(edges):

    X_arr=edges.shape[0]
    Y_arr=edges.shape[1]
    euclid_dist=int(np.round(np.sqrt(X_arr**2 + Y_arr**2)))
    # create initial r and theta array 
    theta= np.deg2rad(np.arange(-90,90))
    rho=np.linspace(-euclid_dist,euclid_dist,2*euclid_dist)
    # r=np.linspace()
    # create a accumulator which stores r nd theta nd initialise it to zero
    accum=np.zeros((2*euclid_dist,len(theta)))
    # def carttopolar(x,y):
    #   r= math.sqrt(x**2 + y**2)
    #   theta=math.atan(math.abs(y/x))
    #   if (x>=0 and y>=0):
    #     theta=theta
    #   elif (x<0 and y>=0):
    #     theta= 3.1457-theta
    #   elif (x<0 and y<0):
    #     theta=3.1457+theta
    #   else:
    #     theta=-theta
    #   return r,theta
    lines=[]
    for x in range(X_arr):
      for y in range(Y_arr):
        if edges[x,y]>0:
          for k in range(len(theta)):
            t1=np.cos(theta[k])
            t2=np.sin(theta[k])
            r=int((y*t1)+(x*t2))
            accum[r+euclid_dist,k] +=1
    return accum , rho , theta

accum,rho,theta=HoughTrans(edges)
cv2_imshow(accum)

# for theta

# print(rho)
# idx = np.argmax(accum)
# # print(rho.shape)
# print(accum.shape[1])
# q=int(idx /accum.shape[1])
# rho = int(rho[q])
# theta1 = theta[int(idx % accum.shape[1])]
# print("rho={0:.0f}, theta={1:.0f}".format(rho, np.rad2deg(theta1)))
h, theta, rho = hough_line_peaks(accum, theta, rho)
fig, ax = plt.subplots()
ax.imshow(img, cmap=plt.cm.gray)
for idx, angle in enumerate(theta):
    y0 = (rho[idx] - 0 * np.cos(angle)) / np.sin(angle)
    y1 = (rho[idx] - img.shape[1] * np.cos(angle)) / np.sin(angle)
    ax.plot((0, img.shape[1]), (y0, y1), '-r')
ax.set_xlim((0, img.shape[1]))
ax.set_ylim((img.shape[0], 0))
ax.set_axis_off()
ax.set_title('Detected lines')
plt.show()

lines1 = cv.HoughLines(edges, 1, np.pi / 180, 150, None, 0, 0)
cdst1 = cv.cvtColor(edges, cv.COLOR_GRAY2BGR)
cdstP1 = np.copy(cdst1)
dist=[]
slope=[]
if lines1 is not None:
    for i in range(0, len(lines1)):
        rho = lines1[i][0][0]
        theta = lines1[i][0][1]
        a = math.cos(theta)
        b = math.sin(theta)
        x0 = a * rho
        y0 = b * rho
        x1,y1 = (int(x0 + 1000*(-b)), int(y0 + 1000*(a)))
        x2,y2 = (int(x0 - 1000*(-b)), int(y0 - 1000*(a)))
        d=(((x1-x2)**2 + (y1-y2)**2)**0.5)
        dist.append(d)
        if((x2-x1)and (x1-x2))==0:
         m=1.57
        else:
         m=abs(y2-y1)//abs(x2-x1)
        slope.append(m)
        print(x1,x2,y1,y2)
        cv.line(cdst1, (x1,y1), (x2,y2), (0,0,255), 3, cv.LINE_AA)
        # print(pt1,pt2)
        cv2_imshow(cdst1)