# -*- coding: utf-8 -*-
"""M22MA002_PA3Q4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FnJCmu8U9Y0p4GgRKTBdj5FbYT01H532
"""

# pip install scikit-learn
import numpy as np
import matplotlib.pyplot as plt
from sklearn import svm
from skimage.feature import hog
# from sklearn.svm import SVC
from sklearn.model_selection import cross_val_score
from google.colab.patches import cv2_imshow
from sklearn.metrics import precision_recall_curve, average_precision_score
from sklearn.metrics import classification_report,accuracy_score
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
import os
import cv2
import numpy as np

from google.colab import drive
drive.mount('/content/drive')

# !unzip -qq /content/drive/MyDrive/data.zip

import glob 

img_dir = "/content/drive/MyDrive/testimagedeer" # Enter Directory of all images  
data_path = os.path.join(img_dir,'*g') 
files = glob.glob(data_path) 
test_data = [] 
for f1 in files: 
    img = cv2.imread(f1)
    # Image= cv2.resize(img, (64, 64))
    # img=cv2.cvtColor(Image, cv2.COLOR_BGR2GRAY)
    test_data.append(img)

import glob 
img_dir = "/content/drive/MyDrive/Deerimages" # Enter Directory of all images  
data_path = os.path.join(img_dir,'*g') 
files = glob.glob(data_path) 
deer_data = [] 
for f1 in files: 
    img = cv2.imread(f1) 
    # Image= cv2.resize(img, (64,64))
    deer_data.append(img)

import glob 
img_dir = "/content/drive/MyDrive/Nondeerimage" # Enter Directory of all images  
data_path = os.path.join(img_dir,'*g') 
files = glob.glob(data_path) 
nondeer_data = [] 
for f1 in files: 
    img = cv2.imread(f1)
    nondeer_data.append(img)

print("Some of the deer images from deer dataset")
cv2_imshow(deer_data[0])
cv2_imshow(deer_data[1])
cv2_imshow(deer_data[2])
cv2_imshow(deer_data[3])

print("Some of the Patch images from nondeer dataset")
cv2_imshow(nondeer_data[0])
cv2_imshow(nondeer_data[1])
cv2_imshow(nondeer_data[2])
cv2_imshow(nondeer_data[3])

# Compute HOG features for deer and non-deer image 
def computeHOG(img, size=(10, 10), block=(2, 2), nbins=9):
# def compute_hog_features(img, cell_size=(4, 4), block_size=(4, 4), nbins=14):
    
    
    # resize and convert into gray
    imggray = cv2.cvtColor(cv2.resize(img, (100, 100)), cv2.COLOR_RGB2GRAY)
    
    # Compute the HOG features
    hog_f ,hog_img = hog(imggray, orientations=nbins, pixels_per_cell=size,
                       cells_per_block=block, transform_sqrt=True,visualize =True, block_norm='L2-Hys')
    
    return hog_f

deer_hog_features = []



# Compute HOG features for deer images
deer_hog_features = []
for img in deer_data:
    hog_features = computeHOG(img)
    deer_hog_features.append(hog_features)

# Compute HOG features for non-deer images
nondeer_hog_features = []
for img in nondeer_data:
    hog_features = computeHOG(img)
    nondeer_hog_features.append(hog_features)


from sklearn.utils import shuffle
# # Concatenate the features and labels into arrays
# X_train = np.vstack((deer_hog_features, non_deer_hog_features))
# y_train = np.concatenate((np.ones(len(deer_hog_features)), np.zeros(len(non_deer_hog_features))))
print(len(deer_hog_features))
len_d=len(deer_hog_features) 
len_nd=len(nondeer_hog_features)
# Concatenate the features and labels into arrays
X_tr = np.vstack((deer_hog_features, nondeer_hog_features))
y_tr = np.concatenate(((np.ones(len_d), np.zeros( len_nd))),axis=0)
# Shuffle the data
X_tr, y_tr = shuffle(X_tr, y_tr, random_state=45)


# Train an SVM classifier
clfsvm = svm.SVC(kernel='linear',probability = True,C = 1.0)
clfsvm.fit(X_tr, y_tr)

Acc_res = cross_val_score(clfsvm, X_tr, y_tr, cv=5)
# Y_pr=clfsvm.predict(y_tr)

# Evaluate the classifier
print(f"Accuracy: mean: {Acc_res.mean()}")




# Extract HOG features for TEST deer images
testdeer_hog_features=[]
# Compute HOG features for deer images
testdeer_hog_features =[ computeHOG(img) for img in test_data]


# Concatenate the test features into an array
X_ts = np.array(testdeer_hog_features)
print(X_ts.shape)
# True labels for the test images
y_ts = np.ones(len(test_data)-5)
y5=np.zeros(5)
y_ts=np.concatenate((y_ts,y5))
X_ts, y_ts = shuffle(X_ts, y_ts, random_state=42)
# Predict labels for the test images using the trained SVM classifier
y_pred = clfsvm.predict(X_ts)
print(f"Total no. of test images are {len(test_data)}")
print(f"Some of the prediction samples are :-{y_pred[10:16]}")


# Compute accuracy, precision, recall, and F1-score

print(f"THE PERFORMANCE OF THE CLASSIFICATION MODEL OF DEER VS NON-DEER:")
print(f"Accuracy score of the model is:::::{accuracy_score(y_ts, y_pred)}")
print(f"precision_score of the model is:::::{precision_score(y_ts, y_pred)}")
print(f"f1_score  of the model is:::::{f1_score(y_ts, y_pred)}")

# from google.colab.patches import cv2_imshow
import matplotlib.pyplot as plt

#Sample of the classification
cv2_imshow(test_data[0])
print(f"Label of the test image of above image is:{y_pred[0]}")
# from google.colab.patches import cv2_imshow

# Implement sliding window object detection.
def sliding_window(image, step_size, window_size):
    for y in range(0, image.shape[0], step_size):
        for x in range(0, image.shape[1], step_size):
            yield (x, y, image[y:y + window_size[1], x:x + window_size[0]])

def iou_score(box1, box2,area_first=False):
    # Calculate the coordinates of the intersection rectangle
    x1 = max(box1[0], box2[0])
    y1 = max(box1[1], box2[1])
    x2 = min(box1[2], box2[2])
    y2 = min(box1[3], box2[3])

    # Calculate the area of the intersection rectangle
    intersection_area = max(0, x2 - x1 + 1) * max(0, y2 - y1 + 1)

    # Calculate the area of each bounding box
    box1_area = (box1[2] - box1[0] + 1) * (box1[3] - box1[1] + 1)
    box2_area = (box2[2] - box2[0] + 1) * (box2[3] - box2[1] + 1)

    # Calculate the union area by subtracting the intersection area from the sum of the areas of the two bounding boxes
    union_area = box1_area + box2_area - intersection_area

    # Calculate the IoU as the intersection over the union
    iou_score = intersection_area / union_area

    return iou_score
def non_max_suppression2(boxes, result, thresh):
  
    if len(boxes) == 0:
        return []

    # Sort the boxes by their scores in descending order
    sorted_indices = np.argsort(result)[::-1]

    # Initialize an empty list to store the indices of the boxes that will be kept after NMS
    keep = []

    while len(sorted_indices) > 0:
        # Pick the box with the highest score
        i = sorted_indices[0]
        keep.append(i)

        # Compute the IoU overlap between the picked box and all the remaining boxes
        ious = []
        for j in sorted_indices[1:]:
            iou = iou_score(boxes[i], boxes[j])
            ious.append(iou)

        # Remove the boxes that overlap too much with the picked box
        sorted_indices = sorted_indices[1:][np.array(ious) <= thresh]

    return keep




def find_deer(image, clf, win_size, step_size=8, prob=0.4, threshold=0.3):
    detections = []
    for x in range(0, image.shape[1] - win_size[0] + 1, step_size):
        for y in range(0, image.shape[0] - win_size[1] + 1, step_size):
            window = image[y:y+win_size[1], x:x+win_size[0]]
            hog_features = computeHOG(window).reshape(1, -1)
            prediction, prob1 = clf.predict(hog_features), clf.predict_proba(hog_features)
            if prediction == 1 and np.amax(prob1) > prob:
                detections.append((x, y, win_size[0], win_size[1], np.amax(prob1)))
    
    # Apply non-maximum suppression to eliminate duplicate bounding boxes
    box = np.array([[x, y, x + w, y + h] for (x, y, w, h, p) in detections])
    Acc_res = np.array([p for (x, y, w, h, p) in detections])
    keep = non_max_suppression2(box, Acc_res, threshold)
    detections = [detections[i] for i in keep]
    
    # Sort the detections based on their probability scores in descending order
    detections.sort(key=lambda x: x[4], reverse=True)
    
    # Return the bounding box with the highest score
    if detections:
        return [(detections[0][0], detections[0][1], detections[0][2], detections[0][3])]
    else:
        return []

 


# Set the sliding window parameters
win_size = (400, 400)
size = 40 
data_path = os.path.join("/content/drive/MyDrive/testimagedeer",'*g') 
files = glob.glob(data_path) 
test_data = [] 
for f1 in files: 
    img = cv2.imread(f1)

    img=cv2.resize(img,(500,500))
    # Detect deer in the test image using sliding window
    detects = find_deer(img, clfsvm, win_size, size)

    # Draw bounding boxes around the detected deer
    for (x, y, width, height) in detects:
        
        cv2.rectangle(img, (x, y), (x+width, y+height), (255, 0, 0), 4)

    
    cv2_imshow(img)

!unzip -qq /content/drive/MyDrive/data.zip

"""# **Sliding Window Object detection in the Test Dataset As attached in the question. **"""

# Set the sliding window parameters
win_size = (400, 400)
size = 40 
data_path = os.path.join("/content/deer-test",'*g') 
files = glob.glob(data_path) 
test_data = [] 
for f1 in files: 
    img = cv2.imread(f1)

    # img=cv2.resize(img,(500,500))
    # Detect deer in the test image using sliding window
    detects = find_deer(img, clfsvm, win_size, size)

    # Draw bounding boxes around the detected deer
    for (x, y, width, height) in detects:
        
        cv2.rectangle(img, (x, y), (x+width, y+height), (255, 0, 0), 4)

    
    cv2_imshow(img)

